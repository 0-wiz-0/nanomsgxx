{"name":"nanomsgxx","tagline":"nanomsg binding for C++11","body":"nanomsgxx\r\n=========\r\n\r\nnanomsgxx is a binding of the nanomsg library for C++11.\r\n\r\nChapters\r\n--------\r\n\r\n- [**Design**](http://achille-roussel.github.io/nanomsgxx/pages/design.html)\r\n- [**Messages**](http://achille-roussel.github.io/nanomsgxx/pages/design.html)\r\n- [**Sockets**](http://achille-roussel.github.io/nanomsgxx/pages/design.html)\r\n- [**Protocol**](http://achille-roussel.github.io/nanomsgxx/pages/design.html)\r\n- [**Polling**](http://achille-roussel.github.io/nanomsgxx/pages/design.html)\r\n- [**Timeouts**](http://achille-roussel.github.io/nanomsgxx/pages/design.html)\r\n\r\nBuilding and installing\r\n-----------------------\r\n\r\nnanomsgxx uses waf to drive the build system, you can get more information about\r\nwhat waf is and how it works [here](http://docs.waf.googlecode.com/git/book_17/single.html).\r\n\r\nwaf is packaged with nanomsgxx, all you should need is a python interpreter and\r\nrunning these commands:\r\n```\r\n./waf configure\r\n./waf build\r\n./waf install\r\n```\r\n\r\nThe library and headers will be installed on your system and you'll be able to\r\nlink your program against **libnanomsgxx**.\r\n\r\n\r\nGetting started\r\n---------------\r\n\r\nnanomsgxx aims to provide a very thin abstraction on top of the nanomsg C API,\r\nwhile taking advantage of C++11's features to make the code easier to read and\r\nwrite.\r\n\r\n**Quick example**\r\n```c++\r\n#include <iostream>\r\n#include <system_error>\r\n#include <nnxx/message.h>\r\n#include <nnxx/pair.h>\r\n#include <nnxx/socket.h>\r\n\r\nint main() {\r\n  try {\r\n    nnxx::socket s1 { nnxx::SP, nnxx::PAIR };\r\n    nnxx::socket s2 { nnxx::SP, nnxx::PAIR };\r\n    const char *addr = \"inproc://example\";\r\n\r\n    s1.bind(addr);\r\n    s2.connect(addr);\r\n\r\n    s1.send(\"Hello World!\");\r\n\r\n    nnxx::message msg = s2.recv();\r\n    std::cout << msg << std::endl;\r\n    return 0;\r\n  }\r\n  catch (const std::system_error &e) {\r\n    std::cerr << e.what() << std::endl;\r\n    return 1;\r\n  }\r\n}\r\n```\r\n\r\n**What did we write?**\r\n\r\nYou've probably recognized most of these calls if you're familiar with nanomsg's\r\nAPI. nanomsgxx uses the *nnxx* namespace, here we have...\r\n\r\n- declared two socket objects in the *SP* domain using the *PAIR* protcol\r\nand connected them together\r\n- sent *\"Hello World!\"* from the first socket to the second\r\n- used the *nnxx::socket::recv* method to retrieve the message on the\r\nreceiver side\r\n- printed the received message to stdout\r\n\r\n**A few highlights**\r\n\r\n- as you can expect from a C++ abstraction there's no need to manually tell when\r\nto release resources, this is handled automatically in the destructors\r\n- the *nnxx::message* type automatically manages buffers for zero-copy, making\r\nhigh performance code easy to write.\r\n- error cases are reported throught exceptions that are subclasses of\r\n*std::system_error*\r\n\r\nResources\r\n---------\r\n\r\nnanomsgxx repo: https://github.com/achille-roussel/nanomsgxx\r\n\r\nnanomsg website: http://nanomsg.org/index.html\r\n\r\nnanomsg sources: https://github.com/nanomsg/nanomsg\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}